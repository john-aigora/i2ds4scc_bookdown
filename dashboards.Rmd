```{r include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```
# Dashboards {#dashboards}

## Objectives

For good communication, importance of having the right tool.
Interactivity has always played an important role.
Even better, imagine you are presenting results to your manager and colleagues, and as questions arise, you have a tool that provide answers to most of their questions based on data.

or...

Introduce an experienced situation: I'm sure we've all been through situations in which we spend a lot of time analyzing data for a study, we build our story, spend time in perfecting our presentation: when comes the day of the presentation to your manager and colleagues, you get questions (e.g. how about a split between users/non users, or between gender, etc.) that you can only answer with: "let me re-run some analyses and I'll update you on that!"

Disappointment because 1) you did not think about it, 2) you know that you have to go through all your analyses again, but just on a portion of it...

What if we had a tool that would allow you to provide such results (up to a certain extent) instantly, as the question arises?
This is the role of dashboard: interactivity of results/representations based on updated data (filter, zoom in...) 

## Introduction to Shiny through an Example

Before digging straight into the code, let's shortly introduce what 

### What is Shiny

Shiny is an R package (`{shiny}`) that allows you to directly create from R interactive web applications. The goal of shiny is to 'convert' your R code into an application that can be accessible and used by anyone through their web browser, without seeing any line of code, nor being familiar with R.

This procedure is made available as `{shiny}` uses some carefully curated set of user interface (UI) functions that generate the HTML, CSS, and JavaScript code needed for most common tasks. In most cases, further knowledge of these languages is not required...unless you want to push your application further. Additionally, it introduces a new way of programming called *reactive programming*, which tracks automatically dependencies between code: When a change in an input is detected, any code that is affected by this change will automatically be updated accordingly. 

### Starting with Shiny

To create your very first shiny application, you can click on R studio in the *new page* icon and select *Shiny Web App...*
Once you filled in the relevant information (name, author), you can then decide whether you want to create one unique file (`app.R`) or multiple files (`ui.R` and `server.R`).

Both solutions are equivalent and work the same: In both cases, a `ui()` and a `server()` function are generated. Due to better readability, and to ease its maintenance over time, we recommend to use the single file for short applications, and to use multiple files for larger applications (larger meaning with more code lines).

For our short application, we consider that a single file was more convenient and hence we used that solution.

#### Illustration 

For illustration, let's consider a simple application in which we import a data set that contains sensory data, as collected from a trained panel. In this example, the data set structure follows the one in *Sensory Profile.xlsx*. 

For simplification purposes, the code developed for this application requires that the data set contains one column called *Judge* (containing the panelist information), one column called *Product* (containing the product information), all the other columns being quantitative (corresponding to the sensory attributes).

The goal of the application is then to compute from this raw data set the sensory profiles of the products (mean table with attributes in rows, and products in columns) that we display on screen. Furthermore, we also represent these sensory profiles graphically in a spider plot or in a circular bar plot. 
Since the main goal of shiny application is in its reactivity and interactivity, we give the user the opportunity to remove/add/reorder the attributes on the table and plots, and to hide/show products to increase visibility.

Once the graphics match our needs, we also propose to download it as a *.png* file to integrate it in our report.

From a learning perspective, this application introduces you specifically to:

 - Importing an external file to the application;
 - Create options that that are both independent (type of graph to produce) and depend of the file imported (list of attributes and products);
 - Run some analyses (compute the means) and display the results as a table and as a plot;
 - Export the graph to your computer as a png file. 

#### User Interface

The user interface (UI) is the part of the application that controls what the user sees and controls. 
In our example, the UI is separated into two parts: 

 - the left panel which contains the options that the user can manually change; 
 - the right (or main) panel which contains the outputs.
 
In the *app.R* file, this information is stored in the `ui()` function, and the two panels can be found in `sidebarPanel()` and in `mainPanel()` respectively.

In `sidebarPanel()`, all the options are set up. These options include `fileInput()` for importing the data set, or `radioButtons()` to control the type of plot to generate. A large list of options exist including `numericInput()`, `sliderInput()`, `textInput()`, `passwordInput()`, `dateInput()`, `selectInput()`, `checkboxInput()` etc. Note that we also extended our library of options by adding `checkboxGroupInput()` from the `{shinyjs}` package^[To use `{shinyjs}`, you need to load the library and add `useShinyjs(),` at the start of your `ui()` code.].

In some cases, the option of interest cannot be defined on the UI side since they depend on the data itself. It is the case for the product or attribute selection, which are then defined using `uiOutput()`. As we will seen in the next section, these options are created on the server side.

On `mainPanel()`, `tabsetPanel()` and `tabPanel()` control for the design of the output section. In our example, we create two tabs, one for the table and one for the graph, but we could have opted out to print everything on one page. 

In our case, the `mainPanel()` only aims in exporting results computed on the server side. Depending on the type of output generated, the corresponding function should be used. In this case, we use `tableOutput()` to retrieve the table generated with `renderTable()`, `plotOutput()` to retrieve the plot generated with `renderPlot()`, or `downloadButton()` to retrieve the plot generated with `downloadHandler()`. Generally speaking, the `xxxOutput()` function (UI side) is used to retrieve the output generated (server side) from the corresponding `renderXxx()` function.

#### Server

The server side of the application is where all the computations are being performed, including the construction of tables, figures, etc.

Since the options defined on the UI side should affect the computations performed (e.g. our decision on the type of plot to design should affect the plot generated), we need to communicate these decisions to the server, and use them.
On the server side, any information (or option) passed to the server side is done through `input$name_option`. In our previous example regarding the type of graph to generate, this is shown as `input$plottype`, as defined by:

```{r}
radioButtons("plottype", "Type of Plot to Draw:", 
             choices=c("Spider Plot"="line", "Circular Barplot"="bar"), 
             selected="line", inline=TRUE)
```

In this case, if the user select *Spider Plot* (resp. *Circular Barplot*), `input$plottype` will take the value *line* (resp. *bar*).

Reversely, any information that is being build on the server side and that should be passed on the UI part of the application can either be done via the `xxxOutput()`/`renderXxx()` combination presented before (useful for showing results), or by using the `renderUI()`/`uiOutput()` combination (useful for options that are *server-dependent*). 

Following a similar communication system than the one from UI to server, the part generated on the server side is stored as `output$name_option` (defined as `renderUI()`) and is captured on the UI side using `uiOutput("name_option")`.

In our example, the latter combination is used for the two options that require reading the data set first, namely the selection of attributes and the selection of products.

```{r}

# server side:
  output$attribute <- renderUI({
    
    req(mydata())
    
    items <- mydata() %>% 
      pull(Attribute) %>% 
      as.character() %>% 
      unique()
    
    selectInput("attribute", "Select the Attributes (in order) ", choices=items, selected=items, multiple=TRUE)
    
  })

  output$product <- renderUI({
    
    req(mydata())
    items <- mydata() %>% 
      pull(Product) %>% 
      unique()
    
    checkboxGroupInput("product", "Select the Products to Display:", choices=items, selected=items)
    
  })
  
# UI side:
  uiOutput("attribute")
  uiOutput("product")

```

Lastly, we have elements that are only relevant on the server side, namely the computation themselves. In our example, these are results of a function called `reactive()`.

Reactivity (and its corresponding `reactive()` function) is a great *lazy* feature of `{shiny}` that was designed so that the computations are only performed when necessary, i.e. when the changes applied in the options affect the computations. This laziness is of great power since only computations that are strictly needed are being performed, hence increasing speed by limiting the computation power required to its minimum. 

Let's break this down in a simple example:

```{r}
  mydata <- reactive({
    
    req(input$datafile)
    data <- readxl::read_xlsx(input$datafile$datapath, sheet=1) %>% 
      pivot_longer(-c(Judge, Product), names_to="Attribute", values_to="Score") %>% 
      mutate(Attribute = fct_inorder(Attribute), Score = as.numeric(Score)) %>% 
      group_by(Product, Attribute) %>% 
      summarize(Score = mean(Score)) %>% 
      ungroup()
    
    return(data)
    
  })

```


In this section, we read the file that was selected through the `fileInput()` option called `datafile` from the UI side. Note that in this case, the path of the file is stored in the object called `datapath`, meaning that to access this file, we need to read `input$datafile$datapath`.

Once read (here using `{readxl}`), we do some small transformations to the data before saving its final version in an object called `mydata`. Since this block of code only depends on `input$datafile` (UI side), this part will no longer be in use unless `datafile` is being updated or changed.

For the mean computation, the same procedure applies as well: 

```{r}
  mymean <- reactive({
    
    req(mydata(), input$attribute, input$product)
    mymean <- mydata() %>% 
      mutate(across(c("Product", "Attribute"), as.character)) %>%
      filter(Attribute %in% input$attribute) %>% 
      mutate(Product = factor(Product, input$product),
             Attribute = factor(Attribute, input$attribute),
             Score = format(round(Score, 2), nsmall=2)) %>% 
      pivot_wider(names_from=Product, values_from=Score)
    
    return(mymean)
  })
```

For this `reactive()` block, `mymean` depends on `mydata`, `input$attribute`, and `input$product`. This means that if `datafile` (meaning that `mydata` changes), `input$attribute` and/or `input$product` change, the computations will be redone and `mymean` is getting updated.

Remarks/Comments:

 - Put in reactive as much code as possible: notice that we create the graphs in reactive, and we retrieve them when displaying the graph (thanks to laziness of reactive)
 - Results from reactive should be called as a function: here we do not call it mydata by mydata(). If mydata had two comments, say mydata$data and mydata$properties, we would retrieve the element as mydata()$data for instance.
 - Use of the function req() to avoid getting error: example with the options attribute and product
 - Mention some alternative options, including reactiveEvent() etc. to add for instance a button that computations are only run if the button is being pushed. Mention that in our case, every time we remove an attribute/product, the application is busy: we could make it so that we only update the application after clicking on a button called "Update".


### Tips

`{shiny}` provides tools to design your outputs the way you want. In practice, each panel is based on tables with as many rows as needed, and up to 12 columns. When not specified, the whole width of the screen is used, but this could be controlled (or options could be set side by side) through the `column()` function. 

The `tableOutput()`/`renderTable()` combination is very handy, yet limited in its layout. Many additional packages provide solution to build more flexible tables. In particular, we recommend the use of the `{DT}` package as it provides a large variety of design options, including coloring cells or text, merging rows or columns, search/filter fields, interactivity, etc. This is then done through the functions `renderDataTable()` and `dataTableOutput()`, or its concise forms `renderDT()` and `DTOutput()`^[the table should be generated using `datatable()`.]. 

### Deploying the Application

## To go further...

### Extension to other dedicated packages

DT
...

### Improving through CSS and HTML

### Interactive Tutorial

Incorporate Shiny within RMarkdown documents...

### Documentation and Books

Shiny gallery
Books